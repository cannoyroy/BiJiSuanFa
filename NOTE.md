# NOTE

## 第二章 C/C++快速入门

​	注意:有些读者认为学过C++之后就没有必要学C 语言，甚至觉得C语言太麻烦而不学，这是不太正确的。因为就机考使用的语法而言，除了输入和输出部分，其余顺序结构、分支结构、循环结构、数组、指针都是几乎一样的，学习C语言并不会带来什么负担。对于让C+ 使用者觉得麻烦的scanf函数和printf函数，虽然必须承认cin和cout 可以不指定输入输出格式比较方便，但是cin和cout 消耗的时间比scanf 和printf 多得多，很多题目可能输入还没结束就超时了。

### 2.1 基本数据类型

#### 2.1.1 变量的定义

不能是C语言标识符；第一个字符是字母或者下划线；区分大小写

### 2.1.2 变量类型

![image-20240808231117625](./NOTE.assets/image-20240808231117625.png)

如果longlong 型赋大于 $2^{31}-1$ 的初值，则需要在初值后面加上 **L** ，否则会编译错误。

整型数据前加**unsigned**，无符号，把负数范围挪到整数，取值范围再乘2倍

通过“char c”的方式定义一个字符，那么c被称为“字符变量”，可以被赋值。但对于字符本身，如“c”，无法被改变、赋值，是“字符常量”。C语言中，字符常量统一用ASCII码统一编码。字符常量（必须是单个字符）必须用单引号标注。

`char c = 117;`此处c变量的输出为u，实际上是把ASCII码赋值给了c，而'u'的ASCII码为117。

转义字符/控制字符：不可显示。`\n`表示换行；`\0`表示空字符NULL，注意不是空格。

字符串常量：由双引号标记的字符集，如“nihaoya”。C语言中用字符数组存储。

布尔型中，true=非零，包括正整数和负整数。

### 2.1.3 强制类型转换

`(新类型名)变量名` 浮点数强制转化为整型，直接保留整数部分。

#### 2.1.4 符号常量和const常量

符号常量又称宏定义或者宏替换。`#define 标识符 常量` 或者 `const 数据类型 变量名 = 常量`。同时可以，`#define 标识符 任何语句或片段`，如`#define ADD(a, b) ((a) + (b))`

注意“多加括号”，因为宏定义是直接将对应的部分替换。如以下代码：

```c
#include <stdio.h>
#define CAL(x) (x * 2 + 1)
int main(){
	int a = 1;
	print("%d\n", CAL(a + 1));
	return 0;
}
```

这里会输出4，因为`CAL(a + 1)`实际上是`(a + 1*2 + 1)`，而非`((a+1)*2 + 1)`。

#### 2.1.5 运算符

三目运算符：`A ? B : C`，若A成立，则返回B，否则返回C。

位运算：`<< >> $ \ ^ ~`。其中，`~`为位取反，即0变1，1变0。

### 2.2 顺序结构

#### 2.2.1 赋值表达式

#### 2.2.2 使用scanf和printf输入/输出

##### 1. scanf函数的使用

`scanf(“格式控制”, 变量地址);`如，`scanf("%d", &n);`。

**&的解释：**在C语言中，变量在定义之后，会在计算机内存中分配一块空间给这个变量，该空间在内存中的地质称为变量的地址。为了得到变量地质，需要在变量前加一个`&`（称为**取地址运算符**）。

![image-20240812193147420](./NOTE.assets/image-20240812193147420.png)

其中，数组比较特殊，数组名称本身就代表了数组第一个元素的地址，所以不需要再取地址。

若要实现`hh:mm:ss`这类时间输入，可以这样`scanf("%d:%d:%d", &hh, &mm, &ss);`

若要实现`3 4`这类带空格的输入，`%d`之间可以不加空格。因为除了`%c`，`scanf`对其他格式符的输入是以空白符为结束判断标志的。另外，字符数组使用`%s`读入时，以空格跟换行为读入结束的标志。

```c
int a;
char b, c[10];
scanf("%d%c%s", &a, &b, c);
printf("%d-%c-%s\n", a, b, c);
```

输入`15 a bcd`，输出`15- -a`。

##### 2. printf函数的使用

`scanf(“格式控制”, 变量名称);`

![image-20240812194522391](./NOTE.assets/image-20240812194522391.png)

想输出%或者\，需要DOUBLE。如`printf("%%");``printf("\\");`

**%md：** 使不足m位的`int`型变量以m位进行右对齐输出，其中高位用空格补齐，若本身超过m位，则保持原样。

**%0md：** 与`%md`不同的是，当变量不足m位时，将在前面补足够数量的0而不是空格。

**%.mf：** 可以让浮点数保留m位小数输出，这个“保留”使用**四舍六入五成双**规则。【当需要修约的数字正好是5时，需要根据5前面的数字（即"5的邻居"）来决定是舍去还是进位。如果5前面的数字是偶数，则舍去5；如果5前面的数字是奇数，则进位。这种修约方法在统计学和数据分析中很有用，因为它减少了修约过程中的累积误差，尤其是当对一组数据进行多次修约操作时】

#### 2.2.3 使用getchar和putchar输入/输出字符

`getchar`用来输入单个字符且可以识别并存储换行符，`putchar`用来输出单个字符。

```c
char c1, c2, c3;
c1 = getchar();
getchar();
c2 = getchar();
putchar(c1);
putchar(c2);
putchar(c3);
# input：abcd
# output：acd
```

#### 2.2.4 注释

`/* */` `// `

#### 2.2.5 typedef

给复杂的数据类型起别名：`typedef long long LL;`

#### 2.2.6 常用math函数

`fabs(double x)`：给double型变量取绝对值

`floor(double x)和ceil(double x)`：向下和向上取整

`pow(double r, double p)`：返回 $r^p$

`sqrt(double x)`：算数平方根

`log(double x) / sin(double x) / cos(double x) / tan(double x) / round(double x)`

### 2.3 选择结构

### 2.4 循环结构

### 2.5 数组

### 2.6 函数

### 2.7 指针

### 2.8 结构体

### 2.9 补充

### 2.10 黑盒测试

## 第三章 入门篇（1）——入门模拟

## 第四章 入门篇（2）——算法初步

### 4.1 排序

#### 4.1.1 选择排序

```c++
for(int i = 1;i <= n; i++){
	int k = i;
	for(int j = i; j <= n; j++){
		if(A[j] < A[i])
			k = j;
	}
	int tmp = A[i];
	A[i] = A[k];
	a[k] = tmp;
}
```

#### 4.1.2插入排序

```c++
for(int i = 2; i <= n; i++){
	int tmp = A[i], j = i;
	while(j >  1 && tmp < A[j - 1]){
		A[j] = A[j - 1];
		j--;
	}
	A[j] = tmp;
}
```

#### 4.1.3 排序题与sort函数的应用

1. 结构体定义

   ```c++
   struct Student{
   	char name[10];
   	int id;
   }stu[1001];
   ```

2. cmp函数编写

   ```c++
   bool cmp(Student a, Student B){
   	if(a.score != b.score)	return a.score > b.score;
   	else	return strcmp(a.name, b.name) < 0;
   }
   ```

   `strcmp`用来比较两个char型数组的字典序大小，前者小于后者则返回负数，否则返回正数。

### 4.2 散列

#### 4.2.1 散列的定义与整数散列

题目：给出N个正整数和M个正整数，问M个整数中的元素是否在N个正整数中出现。

用**空间换时间**：若N个正整数中有数字a，则`hashTable[a] = True`，即将输入的数作为数组的下标来进行统计。

**散列（hash）**：将元素通过一个函数转换为整数，使得整数尽量唯一地代表这个元素。这个转换函数称为**散列函数 $H$**。

对于key是整数的情况下，有直接定址法、平方取中法、除留余数法。

直接定址法：恒等变换（ $H(key) = key$ ）或线性变换（ $H(key)=a*key+b$ ）

平方取中法：取key的平方的中间若干位作为hash值

除留余数法： $H(key) = key\ \% \ mod$ 。当 $mod$ 是素数时， $H$ 能尽可能覆盖 $[0, mod)$ 范围内的每个数

除留余数法中，可能会有2个不同的数，但是会有相同的HASH值，以下是三种解决冲突的方法：

1. 线性探查法（Linear Probing）

   暴力循环下一个位置，看是否空

2. 平方探查法（Quadratic Probing）

   找 $H(key)^2 + k^2$ / $H(key)^2 - k^2$ ，其中$k \in [0, Tsize)$。若变成负数，则取 $((H(key)-k^2) \% Tsize + Tsize)\%Tsize$

3. 链地址法（拉链法）

   将所有 $H(key)$ 相同的key连接成一条单链表。`Link[h]`存放`H(key)=h`的一条单链表

#### 4.2.2 字符串hash初步

将字符串映射称为一个整数，使得该整数尽可能唯一地代表字符串。

将每个字母视作0~25、 26~51，采用52进制转化位十进制。

  ### 4.3 递归

#### 4.3.1 分治（divide and conquer）

把原问题拆分为若干个规模较小而结构与原问题相同或相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即课得到为原问题的解。

严格来讲：把子问题个数为1的情况称为减治（decrease and conquer），而把子问题个数大于1的情况称为分治。

#### 4.3.2 递归

递归在于反复调用自身函数，但是每次都把问题范围缩小，直到范围缩小到可以直接得到边界数据的结果，然后在返回的路上求出对应的解。

两个概念：递归边界，递归式（或称 递归调用）。

### 4.4 贪心

#### 4.4.1 简单贪心

考虑当前状态下局部最优（或较优）的策略，来使全局的结果达到最优（或较优）。证明的一般思路是使用反证法以及数学归纳法。

#### 4.4.2 区间贪心

给出N个开区间(x, y)，从中选择尽可能多的开区间，使得这些开区间两两没有交集。

### 4.5 二分

#### 4.5.1 二分查找

原理不提。注意：`mid = (left + right) / 2`可能会发生超过`int`而导致溢出，此处可以使用`mid = left + (right - left)/2`。

#### 4.5.2 二分法拓展

除了整数情况下的二分查询问题，当`right - left < 1e-5`时满足精度要求。一般用`eps`表示精度。

#### 4.5.3 快速幂

##### 1. 递归写法

$给定三个正整数a、b、m\ (a < 10^9, b<10^{18}, 1<m< {10}^9)，求\ a^b \%m$ 

1. 如果$b$是奇数，那么有 $a^b=a*a^{b-1}$
2. 如果$b$是偶数，那么有 $a^b=a^{b/2}*a^{b/2}$

```c++
typedef long long int ll;

LL binaryPow(LL a, LL b, LL m){
    if(!b)  return 1;
    if(b & 1)   return a * binaryPow(a, b - 1, m) % m;
    else{
        LL mul = binaryPow(a, b / 2, m);
        return mul * mul % m;
    }
}
```

细节注意：如果初始a大于等于m，那么需要在进入函数前让a对m去模。

##### 2. 迭代写法

对于$a^b$来说，b可以写成若干二次幂之和。 $a^b表示为a^{2k}……a^8a^4a^2a^1$ 中若干项的乘积。

```c++
typedef long long int LL;

LL binaryPow(LL a, LL b, LL m){
	LL ans = 1;
	while(b > 0){
		if(b & 1){
			ans = ans * a % m;
		}
		a = a * a % m;
		b >>= 1;
	}
	return ans;
}
```

### 4.6 two points

#### 4.6.1 什么是 two points

给定一个递增的正整数数列序列和一个正整数M，求序列中的两个不同位置的数a和b，使得它们的和恰好为M。

```c++
while(i < j){
	if(a[i] + a[j] == m){
		printf("%d %d\n", i, j);
		i++;
		j--;
	}else if(a[i] + a[j] < m){
		i++;
	}else{
		j--;
	}
}
```

#### 4.6.2 归并排序

2-路归并排序。2-路归并持序的原理是，将序列两分组，将序列归并为 $\lceil \frac{n}{2} \rceil$ 个组，组内单独排序；然后 将这些组再两两归并，生成 $\lceil \frac{n}{4} \rceil$ 个组，组内再单独排序；以此类推，直到只剩下一个组为止。

##### 1. 递归实现

……

##### 2. 非递归实现

```c++
void mergeSort(int A[]){
	// step 为组内元素个数，step / 2为左子区间元素个数，等号可以不取
	for(int step = 2; step / 2 <= n; step *= 2){
		// 每step个元素为一组，组内前step/2和后step/2个元素合并
		for(int i = 1; i <= n; i+= step){
			int mid = i + step / 2 - 1;
			if(mid + 1 <= n){ // 存在右子区间则合并
				merge(A, i, mid, mid+1, min(i + step - 1, n));
			}
		}
	}
}
```

#### 4.6.3 快速排序

对于序列 $A[1],A[2]……A[n]$ ，调整序列中元素的位置，使得 $A[i]$ 的左侧所有元素都不超过 $A[i]$ ，$A[i]$ 右侧的所有元素都大于 $A[i]$ 。

这里采用速度较快的tow points思想。

```c++
void Partition(int A[], int left, int right){
	int temp = A[left];
	while(left < right){
		while(left < right && A[right] > temp)	right--;
        // 反复左移，找到不符合条件的元素
		A[left] = A[right];
		while(left < right $$ A[left] <= temp)	left++;
		A[right] = A[left];
	}
	A[left] = temp;
	return left;
}

void quickSort(int A[], int left, int right){
    int(left < right){
        int pos = Partition(A, left, right);
        quickSort(A, left, pos - 1);
        quickSort(A, pos + 1, right);
    }
}
```

快速排序算法当序列中元素的排列比较随机市销率最高，但是序列元素接近有序时，会达到最坏时间复杂度 $O(n^2)$，导致原因主要是主元无法把当前区间划分为两个长度接近的子区间。结局方案是随机选择主元。

需注意，rand()函数只能产生 $[0, RAND __  MAX]$ 范围内的整数，为了避免 $[a,b]$ 超出范围的情况，可以采用： $round(1.0*rand()/RAND\_MAX*(right-left)+left)$ 。

### 4.7 其他高效技巧与算法

#### 4.7.1 打表

用空间换时间，将所有可能需要用到的结果事先计算出来，这样后面需要的时候直接查表获得。

1. 在程序中一次性计算出所有需要用到的结果，之后的查询直接取这些结果。
2. 在程序B中分一次或者多次计算出所有需要用到的结果，手工把结果写在程序A的数组中，然后在程序A中就可以直接使用这些结果。
3. 一些感觉不会做的题，先用暴力程序计算小范围数据的结果，然后找规律。

#### 4.7.2 活用递推

有很多题目需要细心考虑过程中是否可能存在递推关系，如果能找到这样的递推关系，就能使时间复杂度下降不少。例如就一类涉及序列的题 目来说，假如序列的每一位所需要计算的值都可以通过该位左右两侧的结果计算得到，那么就可以考虑所谓的“ 左右两侧的结果” 是否能通过递推进行预处理来得到，这样在后面的使用中就可以不必反复求解。

#### 4.7.3 随机选择算法

从一个无序的数组中求出第K大的数。相比排序，可以使用随机选择算法，可以对任何输入达到 $O(n)$ 期望时间复杂度。

```c++
// 从A[left, right]返回第K大的数
int randSelect(int A[], int left, int right, int K){
    if(left == right)	return A[left];
    int p = randPartition(A, left, right);
    int M = p - left + 1; // 第M大
    if(k == M)	return A[p];
    if(K < M){
        return randSelect(A, left, p - 1, K); // 往左侧找
    }else{
        return randSelect(A, p + 1, right, K - M);
    }
}
```

## 第五章 入门篇（3）——数学问题

## 第六章 STL

——Standard Template Library

### 6.1 vector的常见用法详解

vector，理解为 “长度可自动改变的数组”，可以用来以邻接表的方式存储图。

#### 1. vector定义

`vector<typename> name;` 如果`typename`也是一个STL容器，那么需要在`>>`符号间加上空格，因为C++11之前的标准编译器会把它视为移位操作，导致编译错误。

#### 2. vector容器内元素的访问

##### （1）下标访问

##### （2）迭代器访问

## 第七章 提高篇（1）——数据结构专题（1）

## 第八章 提高篇（2）——搜索专题

## 第九篇 提高篇（3）——数据结构专题（2）

## 第十章 提高篇（4）——图算法专题

## 第十一章 提高篇（5）——动态规划专题

## 第十二章 提高篇（6）——字符串专题

## 第十三章 专题扩展

